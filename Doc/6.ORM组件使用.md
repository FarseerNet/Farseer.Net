### Data ORM组件使用
模块名：`DataModule`
支持：MySql/ClickHouse/Sqlserver/Sqlite/Oracle/Oledb（Access/Execl） 等多种数据库
### 针对Mysql驱动
由于官方的`MySql.Data`没有实现真正意义上的`异步API`，因此框架改由使用`MySqlConnector驱动`，该驱动可通过`nuget`安装

### 使用示例
`贫血模型`
```c#
/// <summary> 数据库实体 </summary>
public class TaskGroupPO
{
    /// <summary>
    /// 主键
    /// </summary>
    [Field(Name = "id", IsPrimaryKey = true, IsDbGenerated = true)]
    public int? Id { get; set; }

    /// <summary>
    /// 任务组标题
    /// </summary>
    [Field(Name = "caption")]
    public string Caption { get; set; }

    /// <summary>
    /// 实现Job的特性名称（客户端识别哪个实现类）
    /// </summary>
    [Field(Name = "job_name")]
    public string JobName { get; set; }

    /// <summary>
    /// 传给客户端的参数，按逗号分隔
    /// </summary>
    [Field(Name = "data", StorageType = EumStorageType.Json)]
    public Dictionary<string, string> Data { get; set; }

}
```
`数据库上下文`
```c#
/// <summary> 数据库上下文 </summary>
public class MysqlContext : DbContext<MysqlContext>
{
    public MysqlContext() : base("default")
    {
    }

    public TableSet<TaskGroupPO> TaskGroup { get; set; }

    protected override void CreateModelInit()
    {
        TaskGroup.SetName("task_group");
    }
}
```
`数据库操作`
```c#
/// <summary> 任务数据库层 </summary>
public class TaskGroupAgent : ISingletonDependency
    {
        /// <summary>
        /// 获取所有任务组列表
        /// </summary>
        public Task<List<TaskGroupPO>> ToListAsync() => MysqlContext.Data.TaskGroup.ToListAsync();

        /// <summary>
        /// 获取任务组信息
        /// </summary>
        public Task<TaskGroupPO> ToEntityAsync(int id) => MysqlContext.Data.TaskGroup.Where(o => o.Id == id).ToEntityAsync();

        /// <summary>
        /// 更新任务组信息
        /// </summary>
        public Task UpdateAsync(int id, TaskGroupPO taskGroup) => MysqlContext.Data.TaskGroup.Where(o => o.Id == id).UpdateAsync(taskGroup);

        /// <summary>
        /// 添加任务组
        /// </summary>
        public async Task<int> AddAsync(TaskGroupPO po)
        {
            await MysqlContext.Data.TaskGroup.InsertAsync(po, true);
            return po.Id.GetValueOrDefault();
        }

        /// <summary>
        /// 删除当前任务组下的所有
        /// </summary>
        public async Task DeleteAsync(int taskGroupId)
        {
            await MysqlContext.Data.TaskGroup.Where(o => o.Id == taskGroupId).DeleteAsync();
        }
    }
```
在使用ORM组件时，需要先定义好DbContext上下文。

并设置好你的表模型到TableSet中。

#### 工作单元模式
在不使用事务时，推荐使用工作单元模式，更为方便
```c#
MysqlContext.Data.Task.xxxxx;
//e.g
MysqlContext.Data.Task.Where(o => o.Id == id).Delete();
```

#### 事务使用
如果需要事务时，则需要以new的方式使用
```c#
using (var db = new MysqlContext())
{
    db.Task.Where(o => o.Id == id).Delete();
    db.Commit();
}
```

#### 合并事务
在我们划分多个业务模块时，如果需要将两个业务的上下文合并在一个事务里时，需要特殊的使用
```c#
public void Doing()
{
    using (var db = new MysqlContext())
    {
        OtherDoing(db);
        db.Commit();
    }
}

public void OtherDoing(DbContext otherDb)
{
    var order = MysqlContext.TransactionInstance(otherDb);
    order.xxxxx;
}
```

#### 使用json存储
```c#
[Field(StorageType = EumStorageType.Json)]
public Dictionary<string, string> Data { get; set; }
```
`StorageType`定义了值的存储方式为Json，本示例使用的是Dictionary类型，你也可以使用任何class对象。
这样将会使用json序列化的方式把数据存储到数据库中。

#### 使用Array存储
```c#
[Field(StorageType = EumStorageType.Array)]
public List<string> Data { get; set; }
```

在存储到数据库时，将以`,`符合分隔后存储到数据库。
如：1,2,3,4,5,a,b,c

如果你使用`领域驱动DDD`来设计`仓储层`时，将`值对象`序列化到数据库是一种不错的选择。